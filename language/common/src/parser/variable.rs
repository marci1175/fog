use std::sync::atomic::AtomicUsize;

use crate::{
    codegen::{FunctionArgumentIdentifier, StructAttributes},
    error::{parser::ParserError, syntax::SyntaxError},
    parser::{
        common::{ParsedTokenInstance, find_closing_paren},
        function::{FunctionDefinition, parse_function_call_args},
    },
    tokenizer::Token,
    ty::{OrdMap, Type},
};
use strum_macros::Display;

#[derive(Debug, Clone, Display, PartialEq, Eq, Hash)]
pub enum ControlFlowType
{
    Break,
    Continue,
}

pub type UniqueId = usize;

/// Wrapper (around [`AtomicUsize`]) [`IdSource`] type.
/// [`AtomicUsize`] with a simplified function interface.
#[derive(Debug)]
pub struct IdSource
{
    inner: AtomicUsize,
}

impl IdSource
{
    /// Creates a new [`IdSource`] with a starting id.
    pub const fn new(starting_id: usize) -> Self
    {
        Self {
            inner: AtomicUsize::new(starting_id),
        }
    }

    /// Fetches current [`AtomicUsize`] state and increments it by one.
    pub fn get_unique_id(&self) -> UniqueId
    {
        self.inner
            .fetch_add(1, std::sync::atomic::Ordering::Relaxed)
    }

    /// Sets the current internal state of the [`IDSource`].
    pub fn set_current_unique_id(&self, id: UniqueId)
    {
        self.inner.store(id, std::sync::atomic::Ordering::Relaxed);
    }

    /// Fetches the current state of the internal [`AtomicUsize`].
    pub fn get_current_id(&self) -> usize
    {
        self.inner.load(std::sync::atomic::Ordering::Relaxed)
    }
}

/// This static is a Variable Id source. This means that all of the variables (function argmuents included) have a unqiue id generated by this function.
/// This is crucial when implementing a pre allocation table for loops
pub static VARIABLE_ID_SOURCE: IdSource = IdSource::new(0);

#[derive(Debug, Clone, Display, PartialEq, Eq, Hash, strum_macros::EnumTryAs)]
/// VariableReferences are the lowest layer of referencing a variable. This is enum wrapped in a ParsedToken, consult the documentation of that enum variant for more information.Å±
/// VariableReferences should not contain themselves as they are only for referencing a variable, there is not much more to it.
pub enum VariableReference
{
    /// Struct field reference
    StructFieldReference(StructFieldRef),
    /// Variable name and custom identifier number (in current scope)
    BasicReference(String, usize),
    /// Variable name, array index
    ArrayReference(ArrayIndexing),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct StructFieldRef
{
    /// Variable reference enum this shows the underlying variable its referring from
    pub variable_ref: Box<VariableReference>,
    /// This field is for verifying types (Even if the struct fields match it could still be two different structs)
    pub struct_name: String,
    /// The actual struct body, this contains the fields paired with their types. (In order of insertion)
    /// This field uses an [`OrdMap`] so that [`Hash`] can be implemented.
    pub struct_fields: OrdMap<String, Type>,
    /// This is the fields name we are refering
    pub field: StructFieldType<
        String,
        (
            FunctionSignature,
            OrdMap<
                FunctionArgumentIdentifier<String, usize>,
                (ParsedTokenInstance, (Type, UniqueId)),
            >,
        ),
    >,
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum StructFieldType<F, FN>
{
    Field(F),
    Function(FN),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ArrayIndexing
{
    pub variable_reference: Box<VariableReference>,
    pub idx: Box<ParsedTokenInstance>,
}

/// The first item of the StructFieldReference is used to look up the name of the variable which stores the Struct.
/// The functions which take the iterator of the `field_stack` field should not be passed the first item of the iterator, since the first item is used to look up the name of the variable which stores the struct.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct StructFieldReference
{
    /// The name of the fields which get referenced
    pub field_stack: Vec<String>,
}

impl Default for StructFieldReference
{
    fn default() -> Self
    {
        Self::new()
    }
}

impl StructFieldReference
{
    /// Creates an instnace from a single entry
    pub fn from_single_entry(field_name: String) -> Self
    {
        Self {
            field_stack: vec![field_name],
        }
    }

    /// Initializes an instance from a list of field entries
    pub fn from_stack(field_stack: Vec<String>) -> Self
    {
        Self { field_stack }
    }

    /// Creates an instnace from an empty list
    pub fn new() -> Self
    {
        Self {
            // Most struct references are one field deep, might aswell take a guess
            field_stack: Vec::with_capacity(1),
        }
    }
}

/// Parses the tokens passed in and stores the field names into [`StructFieldReference`].
/// This function returns the last field's type.
/// TODO: When i want to implement traits and the ability to call functions on types. ( function foo(self, x: int) ) This needs modification.
pub fn get_struct_field(
    tokens: &[Token],
    token_idx: &mut usize,
    identifier: &str,
    (struct_name, struct_fields, attributes): &(String, OrdMap<String, Type>, StructAttributes),
    var_ref: &mut VariableReference,
) -> anyhow::Result<StructFieldType<Type, (usize, UnparsedFunctionDefinition)>>
{
    // Match field name
    if let Some(Token::Identifier(field_name)) = tokens.get(*token_idx) {
        // Store field name
        *var_ref = VariableReference::StructFieldReference(StructFieldRef {
            variable_ref: Box::new(var_ref.clone()),
            struct_name: struct_name.clone(),
            struct_fields: struct_fields.clone(),
            field: StructFieldType::Field(field_name.clone()),
        });

        // Lookup struct field
        // If it is not a struct but is a some store the struct field name and return
        if let Some(field_type) = struct_fields.get(field_name) {
            *token_idx += 1;

            // Match syntax
            if let Some(Token::Dot) = tokens.get(*token_idx) {
                // Increment idx
                *token_idx += 1;

                let next_struct_def = field_type
                    .try_as_struct_ref()
                    .ok_or(ParserError::TypeWithoutFields(field_type.clone()))?;

                // Call this function once again and iterate
                get_struct_field(tokens, token_idx, identifier, next_struct_def, var_ref)
            }
            else {
                // Return field type
                Ok(StructFieldType::Field(field_type.clone()))
            }
        }
        // If a function was implemented with this name and it was referenced here we should parse the function call
        // This means that there is a receiver in the function def ie `this`
        else if let Some(impl_fn) = attributes.implemented_unparsed_functions.get(field_name) {
            // Return the function's name we will parse it later, not here (to avoid having to add 1000 arguments to this function too)
            Ok(StructFieldType::Function((impl_fn.token_offset, impl_fn.clone())))
        }
        else {
            Err(ParserError::SyntaxError(SyntaxError::StructFieldNotFound(
                field_name.clone(),
                (struct_name.clone(), struct_fields.clone()),
            ))
            .into())
        }
    }
    else {
        Err(ParserError::SyntaxError(SyntaxError::InvalidStructFieldReference).into())
    }
}

use std::{collections::HashMap, rc::Rc};

use crate::{
    anyhow::Result,
    codegen::CustomItem,
    error::DbgInfo,
    indexmap::IndexMap,
    parser::{
        common::ParsedToken,
        dbg::fetch_and_merge_debug_information,
        function::{FunctionSignature, UnparsedFunctionDefinition},
        value::MathematicalSymbol,
    },
    tracing,
    ty::ty_from_token,
};

use crate::parser::value::{parse_token_as_value, parse_value};

/// This function parses the tokens after a variable.
/// This function parses actions related to variables. Such as: `var + 5` and `var =% 3`, etc.
/// TODO: Make this fn have a side effect on `var_ref` and just wrap the value into a parsed token instance at the end
pub fn resolve_variable_expression(
    tokens: &[Token],
    // Token slice offset, this allows us to keep the correct slice indexing (without ruining token_idx)
    function_token_offset: usize,
    debug_infos: &[DbgInfo],
    token_idx: &mut usize,
    function_signatures: Rc<IndexMap<String, UnparsedFunctionDefinition>>,
    function_imports: Rc<HashMap<String, FunctionSignature>>,
    variable_scope: &mut IndexMap<String, (Type, UniqueId)>,
    (variable_type, variable_id): (Type, UniqueId),
    custom_items: Rc<IndexMap<String, CustomItem>>,
    variable_ref: &mut ParsedTokenInstance,
    parsed_tokens: &mut Vec<ParsedTokenInstance>,
    variable_name: &str,
) -> Result<Type>
{
    let var_ref = variable_ref.inner.try_as_variable_reference_mut().unwrap();
    let origin_token_idx = *token_idx;

    let current_token = tokens.get(*token_idx);

    if let Some(current_token) = current_token {
        match &current_token {
            Token::SetValue => {
                // Find next line break aka `;`
                let line_break_idx = tokens
                    .iter()
                    .skip(*token_idx)
                    .position(|token| *token == Token::SemiColon)
                    .ok_or(ParserError::SyntaxError(SyntaxError::MissingSemiColon))?
                    + *token_idx;

                // Tokens that contain the value we set the variable to
                let selected_tokens = &tokens[*token_idx + 1..line_break_idx];

                // Increment the token_idx to the next expression `Token::LineBreak` + 1
                *token_idx += selected_tokens.len() + 1;

                // Parse the value we would be setting the variable to
                let (parsed_token, _, _) = parse_value(
                    selected_tokens,
                    function_token_offset,
                    debug_infos,
                    origin_token_idx,
                    function_signatures.clone(),
                    variable_scope,
                    Some(variable_type.clone()),
                    function_imports.clone(),
                    custom_items.clone(),
                )?;

                parsed_tokens.push(ParsedTokenInstance {
                    inner: ParsedToken::SetValue(
                        Box::new(variable_ref.clone()),
                        Box::new(parsed_token),
                    ),
                    debug_information: fetch_and_merge_debug_information(
                        debug_infos,
                        function_token_offset + origin_token_idx
                            ..function_token_offset + *token_idx,
                        true,
                    )
                    .unwrap(),
                });
            },
            Token::SetValueAddition
            | Token::SetValueSubtraction
            | Token::SetValueDivision
            | Token::SetValueMultiplication
            | Token::SetValueModulo => {
                set_value_math_expr(
                    tokens,
                    function_token_offset,
                    debug_infos,
                    function_signatures,
                    token_idx,
                    variable_scope,
                    variable_type.clone(),
                    variable_ref,
                    current_token.clone().try_into()?,
                    function_imports.clone(),
                    custom_items.clone(),
                )?;
            },
            Token::OpenSquareBrackets => {
                if !matches!(variable_type, Type::Array(_)) {
                    return Err(ParserError::TypeMismatchNonIndexable(variable_type.clone()).into());
                }

                *token_idx += 1;

                let square_brackets_break_idx = tokens
                    .iter()
                    .skip(*token_idx)
                    .position(|token| *token == Token::CloseSquareBrackets)
                    .ok_or(ParserError::SyntaxError(
                        SyntaxError::LeftOpenSquareBrackets,
                    ))?
                    + *token_idx;

                let selected_tokens = &tokens[*token_idx..square_brackets_break_idx];

                let (value, _idx_jmp, _) = parse_value(
                    selected_tokens,
                    function_token_offset + *token_idx,
                    debug_infos,
                    origin_token_idx,
                    function_signatures.clone(),
                    variable_scope,
                    Some(Type::U32),
                    function_imports.clone(),
                    custom_items.clone(),
                )?;

                *token_idx = square_brackets_break_idx;

                if let Some(Token::CloseSquareBrackets) = tokens.get(*token_idx) {
                    *token_idx += 1;

                    *var_ref = VariableReference::ArrayReference(ArrayIndexing {
                        variable_reference: Box::new(var_ref.clone()),
                        idx: Box::new(value.clone()),
                    });

                    if let Type::Array((inner_ty, _len)) = variable_type.clone() {
                        let ty = resolve_variable_expression(
                            tokens,
                            function_token_offset,
                            debug_infos,
                            token_idx,
                            function_signatures,
                            function_imports,
                            variable_scope,
                            (ty_from_token(&inner_ty, &custom_items)?, variable_id),
                            custom_items,
                            variable_ref,
                            parsed_tokens,
                            variable_name,
                        )?;

                        return Ok(ty);
                    }
                    else {
                        unreachable!(
                            "This is unreachable as there is a type check at the beginning of this code."
                        );
                    }
                }
                else {
                    return Err(
                        ParserError::SyntaxError(SyntaxError::LeftOpenSquareBrackets).into(),
                    );
                }
            },
            Token::Dot => {
                if let Type::Struct(struct_def) = variable_type {
                    *token_idx += 1;

                    // Stack the field names on top of the variable name
                    let struct_field_variant =
                        get_struct_field(tokens, token_idx, variable_name, &struct_def, var_ref)?;

                    let ty = match struct_field_variant {
                        StructFieldType::Field(field_type) => {
                            // Continue parsing it

                            resolve_variable_expression(
                                tokens,
                                function_token_offset,
                                debug_infos,
                                token_idx,
                                function_signatures,
                                function_imports,
                                variable_scope,
                                // Even though this is a field of a struct it still falls under the same original variable id
                                (field_type, variable_id),
                                custom_items,
                                variable_ref,
                                parsed_tokens,
                                variable_name,
                            )?
                        },
                        StructFieldType::Function((token_offset, impl_fn)) => {
                            // Check for syntax
                            if Some(&Token::OpenParentheses) != tokens.get(*token_idx + 1) {
                                return Err(ParserError::InvalidFunctionCallArguments.into());
                            }

                            // Increment cursor
                            // Index should be at the first Token of the function call's args
                            *token_idx += 2;

                            let closing_idx = find_closing_paren(dbg!(&tokens[*token_idx..]), 0)? + *token_idx;

                            let function_call_args_tkns = &tokens[*token_idx..closing_idx];

                            let (call_args, _) = parse_function_call_args(
                                function_call_args_tkns,
                                token_offset,
                                *token_idx,
                                debug_infos,
                                variable_scope,
                                impl_fn.signature.args.clone(),
                                function_signatures.clone(),
                                function_imports.clone(),
                                custom_items.clone(),
                            )?;

                            *var_ref = VariableReference::StructFieldReference(StructFieldRef {
                                variable_ref: Box::new(var_ref.clone()),
                                struct_name: struct_def.0.clone(),
                                struct_fields: struct_def.1.clone(),
                                field: StructFieldType::Function((impl_fn.signature.clone(), call_args)),
                            });

                            // Continue parsing it

                            resolve_variable_expression(
                                tokens,
                                function_token_offset,
                                debug_infos,
                                token_idx,
                                function_signatures,
                                function_imports,
                                variable_scope,
                                (impl_fn.signature.return_type, variable_id),
                                custom_items,
                                variable_ref,
                                parsed_tokens,
                                variable_name,
                            )?
                        },
                    };

                    return Ok(ty);
                }
                else {
                    return Err(ParserError::TypeWithoutFields(variable_type).into());
                }
            },
            Token::SemiColon => {
                *token_idx += 1;
            },
            Token::As => {
                if let Some(Token::TypeDefinition(target_type)) = tokens.get(*token_idx + 1) {
                    // let desired_variable_type =
                    //     desired_variable_type.ok_or(ParserError::InternalDesiredTypeMissing)?;
                    // if *target_type != desired_variable_type {
                    //     return Err(ParserError::TypeMismatch(
                    //         target_type.clone(),
                    //         desired_variable_type,
                    //     )
                    //     .into());
                    // }

                    // Increment the token index after checking target type
                    *token_idx += 2;

                    resolve_variable_expression(
                        tokens,
                        function_token_offset,
                        debug_infos,
                        token_idx,
                        function_signatures,
                        function_imports,
                        variable_scope,
                        (variable_type, variable_id),
                        custom_items,
                        &mut ParsedTokenInstance {
                            inner: ParsedToken::TypeCast(
                                Box::new((*variable_ref).clone()),
                                target_type.clone(),
                            ),
                            debug_information: fetch_and_merge_debug_information(
                                debug_infos,
                                origin_token_idx + function_token_offset
                                    ..origin_token_idx + *token_idx + function_token_offset,
                                true,
                            )
                            .unwrap(),
                        },
                        parsed_tokens,
                        variable_name,
                    )?;

                    // Return the type casted literal
                    return Ok(target_type.clone());
                }
                else {
                    // Throw an error
                    return Err(ParserError::SyntaxError(SyntaxError::AsRequiresTypeDef).into());
                }
            },
            // Everything else should be igonred as we can assume it is a part of another expression
            // All of the variable expressions are captured by the tokens before.
            // Since this function parses everything after the indent, it can happen that only a variable is referenced.
            // In which case, this function would want to parse that expression unrelated to this function.
            // ie: `var1 > var2` Parsing will start at `>` which is not related to the var1 variable
            // This trace can be ignored.
            _ => {
                tracing::trace!("Invalid variable expr token: {}", tokens[*token_idx]);
            },
        }
    }

    // If we didnt return anything before this we can return variable type.
    Ok(variable_type)
}

pub fn set_value_math_expr(
    tokens: &[Token],
    token_offset: usize,
    debug_infos: &[DbgInfo],
    function_signatures: Rc<IndexMap<String, UnparsedFunctionDefinition>>,
    token_idx: &mut usize,
    variable_scope: &mut IndexMap<String, (Type, UniqueId)>,
    variable_type: Type,
    variable_reference: &mut ParsedTokenInstance,
    math_symbol: MathematicalSymbol,
    standard_function_table: Rc<HashMap<String, FunctionSignature>>,
    custom_items: Rc<IndexMap<String, CustomItem>>,
) -> Result<()>
{
    let origin_token_idx = *token_idx;

    *token_idx += 1;

    let eval_token = tokens.get(*token_idx).ok_or(ParserError::SyntaxError(
        SyntaxError::InvalidVariableDefinition,
    ))?;

    let (next_token, _ty) = parse_token_as_value(
        tokens,
        token_offset,
        debug_infos,
        origin_token_idx,
        function_signatures,
        variable_scope,
        Some(variable_type.clone()),
        token_idx,
        eval_token,
        standard_function_table,
        custom_items.clone(),
    )?;

    *variable_reference = ParsedTokenInstance {
        inner: ParsedToken::SetValue(
            Box::new(variable_reference.clone()),
            Box::new(ParsedTokenInstance {
                inner: ParsedToken::MathematicalExpression(
                    Box::new(variable_reference.clone()),
                    math_symbol,
                    Box::new(next_token),
                ),
                debug_information: fetch_and_merge_debug_information(
                    debug_infos,
                    origin_token_idx + token_offset..*token_idx + token_offset,
                    true,
                )
                .unwrap(),
            }),
        ),
        debug_information: fetch_and_merge_debug_information(
            debug_infos,
            origin_token_idx + token_offset..*token_idx + token_offset,
            true,
        )
        .unwrap(),
    };

    Ok(())
}
