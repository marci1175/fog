use std::sync::atomic::AtomicUsize;

use crate::{
    codegen::StructAttributes, error::{parser::ParserError, syntax::SyntaxError}, parser::common::ParsedTokenInstance, tokenizer::Token, ty::{OrdMap, Type}
};
use strum_macros::Display;

#[derive(Debug, Clone, Display, PartialEq, Eq, Hash)]
pub enum ControlFlowType
{
    Break,
    Continue,
}

pub type UniqueId = usize;

/// Wrapper (around [`AtomicUsize`]) [`IdSource`] type.
/// [`AtomicUsize`] with a simplified function interface.
#[derive(Debug)]
pub struct IdSource
{
    inner: AtomicUsize,
}

impl IdSource
{
    /// Creates a new [`IdSource`] with a starting id.
    pub const fn new(starting_id: usize) -> Self
    {
        Self {
            inner: AtomicUsize::new(starting_id),
        }
    }

    /// Fetches current [`AtomicUsize`] state and increments it by one.
    pub fn get_unique_id(&self) -> UniqueId
    {
        self.inner
            .fetch_add(1, std::sync::atomic::Ordering::Relaxed)
    }

    /// Sets the current internal state of the [`IDSource`].
    pub fn set_current_unique_id(&self, id: UniqueId)
    {
        self.inner.store(id, std::sync::atomic::Ordering::Relaxed);
    }

    /// Fetches the current state of the internal [`AtomicUsize`].
    pub fn get_current_id(&self) -> usize
    {
        self.inner.load(std::sync::atomic::Ordering::Relaxed)
    }
}

/// This static is a Variable Id source. This means that all of the variables (function argmuents included) have a unqiue id generated by this function.
/// This is crucial when implementing a pre allocation table for loops
pub static VARIABLE_ID_SOURCE: IdSource = IdSource::new(0);

#[derive(Debug, Clone, Display, PartialEq, Eq, Hash, strum_macros::EnumTryAs)]
/// VariableReferences are the lowest layer of referencing a variable. This is enum wrapped in a ParsedToken, consult the documentation of that enum variant for more information.Å±
/// VariableReferences should not contain themselves as they are only for referencing a variable, there is not much more to it.
pub enum VariableReference
{
    /// Struct field reference
    StructFieldReference(StructFieldRef),
    /// Variable name and custom identifier number (in current scope)
    BasicReference(String, usize),
    /// Variable name, array index
    ArrayReference(ArrayIndexing),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct StructFieldRef
{
    /// Variable reference enum this shows the underlying variable its referring from
    pub variable_ref: Box<VariableReference>,
    /// This field is for verifying types (Even if the struct fields match it could still be two different structs)
    pub struct_name: String,
    /// The actual struct body, this contains the fields paired with their types. (In order of insertion)
    /// This field uses an [`OrdMap`] so that [`Hash`] can be implemented.
    pub struct_fields: OrdMap<String, Type>,
    /// This is the fields name we are refering
    pub field_name: String,
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ArrayIndexing
{
    pub variable_reference: Box<VariableReference>,
    pub idx: Box<ParsedTokenInstance>,
}

/// The first item of the StructFieldReference is used to look up the name of the variable which stores the Struct.
/// The functions which take the iterator of the `field_stack` field should not be passed the first item of the iterator, since the first item is used to look up the name of the variable which stores the struct.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct StructFieldReference
{
    /// The name of the fields which get referenced
    pub field_stack: Vec<String>,
}

impl Default for StructFieldReference
{
    fn default() -> Self
    {
        Self::new()
    }
}

impl StructFieldReference
{
    /// Creates an instnace from a single entry
    pub fn from_single_entry(field_name: String) -> Self
    {
        Self {
            field_stack: vec![field_name],
        }
    }

    /// Initializes an instance from a list of field entries
    pub fn from_stack(field_stack: Vec<String>) -> Self
    {
        Self { field_stack }
    }

    /// Creates an instnace from an empty list
    pub fn new() -> Self
    {
        Self {
            // Most struct references are one field deep, might aswell take a guess
            field_stack: Vec::with_capacity(1),
        }
    }
}

/// Parses the tokens passed in and stores the field names into [`StructFieldReference`].
/// This function returns the last field's type.
/// TODO: When i want to implement traits and the ability to call functions on types. ( function foo(self, x: int) ) This needs modification.
pub fn get_struct_field_stack(
    tokens: &[Token],
    token_idx: &mut usize,
    identifier: &str,
    (struct_name, struct_fields, _): &(String, OrdMap<String, Type>, StructAttributes),
    var_ref: &mut VariableReference,
) -> anyhow::Result<Type>
{
    // Match field name
    if let Some(Token::Identifier(field_name)) = tokens.get(*token_idx) {
        // Lookup struct field
        let struct_field_query = struct_fields.get(field_name);

        // Store field name
        *var_ref = VariableReference::StructFieldReference(StructFieldRef {
            variable_ref: Box::new(var_ref.clone()),
            struct_name: struct_name.clone(),
            struct_fields: struct_fields.clone(),
            field_name: field_name.clone(),
        });

        // If it is not a struct but is a some store the struct field name and return
        if let Some(field_type) = struct_field_query {
            *token_idx += 1;

            // Match syntax
            if let Some(Token::Dot) = tokens.get(*token_idx) {
                // Increment idx
                *token_idx += 1;

                let next_struct_def = field_type
                    .try_as_struct_ref()
                    .ok_or(ParserError::TypeWithoutFields(field_type.clone()))?;

                // Call this function once again and iterate
                get_struct_field_stack(tokens, token_idx, identifier, next_struct_def, var_ref)
            }
            else {
                // Return field type
                Ok(field_type.clone())
            }
        }
        else {
            Err(ParserError::SyntaxError(SyntaxError::StructFieldNotFound(
                field_name.clone(),
                (struct_name.clone(), struct_fields.clone()),
            ))
            .into())
        }
    }
    else {
        Err(ParserError::SyntaxError(SyntaxError::InvalidStructFieldReference).into())
    }
}
