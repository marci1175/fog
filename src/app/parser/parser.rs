use crate::app::{codegen, type_system::type_system::{
    unparsed_const_to_typed_literal_unsafe, TypeDiscriminants
}};
use anyhow::Result;
use indexmap::IndexMap;
use std::{collections::HashMap, sync::Arc};
use strum::IntoDiscriminant;

use super::{
    error::ParserError,
    parse_functions::{self, create_function_table, parse_functions},
    tokens::{FunctionDefinition, FunctionSignature, ParsedToken, Token, UnparsedFunctionDefinition},
};

#[derive(Debug, Clone)]
pub struct ParserState {
    tokens: Vec<Token>,

    function_table: HashMap<String, FunctionDefinition>,
}

impl ParserState {
    pub fn parse_tokens(&mut self) -> Result<()> {
        let unparsed_functions = create_function_table(self.tokens.clone())?;

        let standard_function_table = Arc::new(codegen::codegen::create_function_table());

        self.function_table = parse_functions(Arc::new(unparsed_functions), standard_function_table.clone())?;

        Ok(())
    }

    pub fn new(tokens: Vec<Token>) -> Self {
        Self {
            tokens,
            function_table: HashMap::new(),
        }
    }

    pub fn function_table(&self) -> &HashMap<String, FunctionDefinition> {
        &self.function_table
    }
}

pub fn find_closing_bracket(bracket_start_slice: &[Token]) -> Result<usize> {
    let mut bracket_layer_counter = 1;
    let iter = bracket_start_slice.iter().enumerate();

    for (idx, token) in iter {
        match token {
            Token::OpenBracket => bracket_layer_counter += 1,
            Token::CloseBracket => {
                bracket_layer_counter -= 1;
                if bracket_layer_counter == 0 {
                    return Ok(idx);
                }
            }
            _ => continue,
        }
    }

    Err(ParserError::SyntaxError(super::error::SyntaxError::OpenBracket).into())
}

/// This is a top level implementation for `parse_token_as_value`
pub fn parse_value(
    tokens: &[Token],
    function_signatures: Arc<HashMap<String, UnparsedFunctionDefinition>>,
    variable_scope: &IndexMap<String, TypeDiscriminants>,
    variable_type: TypeDiscriminants,
) -> Result<(ParsedToken, usize)> {
    let mut token_idx = 0;

    let mut parsed_token: Option<ParsedToken> = None;

    while token_idx < tokens.len() {
        let current_token = &tokens.get(token_idx).ok_or({
            ParserError::SyntaxError(
                crate::app::parser::error::SyntaxError::InvalidMathematicalExpressionDefinition,
            )
        })?;

        // Please note that we are not looking at values by themselves, except in SetValue where we take the next token.
        match dbg!(current_token) {
            // If any mathematical expression is present in the tokens
            Token::Addition | Token::Subtraction | Token::Multiplication | Token::Division => {
                // Grab the next token after the mathematical expression
                let next_token = &tokens.get(token_idx + 1).ok_or(ParserError::SyntaxError(
                    crate::app::parser::error::SyntaxError::InvalidMathematicalExpressionDefinition,
                ))?;

                // If we have parsed something already move it to the left-hand side of the mathematical expression
                // Add the new parsed token to the right-hand side of the mathematical expression.
                if let Some(parsed_token) = &mut parsed_token {
                    token_idx += 1;

                    // Modify the parsed token
                    *parsed_token = ParsedToken::MathematicalExpression(
                        // Move the token to the left side
                        Box::new(parsed_token.clone()),
                        // Add the Mathematical symbol to the enum variant
                        (*current_token).clone().try_into()?,
                        // Put the new item to the right side of the expr.
                        Box::new(parse_token_as_value(
                            tokens,
                            &function_signatures,
                            variable_scope,
                            variable_type,
                            &mut token_idx,
                            next_token,
                        )?),
                    );
                } else {
                    return Err(ParserError::SyntaxError(
                        super::error::SyntaxError::InvalidMathematicalExpressionDefinition,
                    )
                    .into());
                }
            }

            // This pattern match is purely for initializing the value of the variable.
            // The ParsedToken generated by the pattern match will not be evaluated in future iterations.
            Token::UnparsedLiteral(_raw_string) => {
                let parsed_value = parse_token_as_value(
                    tokens,
                    &function_signatures,
                    variable_scope,
                    variable_type,
                    &mut token_idx,
                    current_token,
                )?;

                // Initialize parsed token with a value.
                if parsed_token.is_none() {
                    parsed_token = Some(parsed_value.clone());
                }
            }

            // This pattern match is purely for initializing the value of the variable.
            // The ParsedToken generated by the pattern match will not be evaluated in future iterations.
            Token::Literal(_) | Token::Identifier(_) | Token::OpenBracket => {
                let parsed_value = parse_token_as_value(
                    tokens,
                    &function_signatures,
                    variable_scope,
                    variable_type,
                    &mut token_idx,
                    current_token,
                )?;

                // Initialize parsed token with a value.
                if parsed_token.is_none() {
                    parsed_token = Some(parsed_value.clone());
                }
            }

            Token::Comma | Token::CloseBracket | Token::LineBreak => break,

            _ => unimplemented!(),
        }
    }

    Ok((
        parsed_token.ok_or(ParserError::SyntaxError(
            super::error::SyntaxError::InvalidStatementDefinition,
        ))?,
        token_idx,
    ))
}

/// Parses the next token as something that holds a value:
/// Like: FunctionCall, Literal, UnparsedLiteral
pub fn parse_token_as_value(
    // This is used to parse the function call's arguments
    tokens: &[Token],
    // Functions available
    function_signatures: &Arc<HashMap<String, UnparsedFunctionDefinition>>,
    // Variables available
    variable_scope: &IndexMap<String, TypeDiscriminants>,
    // The variable's type which we are parsing for
    variable_type: TypeDiscriminants,
    // Universal token_idx, this sets which token we are currently parsing
    token_idx: &mut usize,
    // The token we want to evaluate
    eval_token: &Token,
) -> Result<ParsedToken> {
    // Match the token
    let inner_value = match eval_token {
        Token::Literal(literal) => {
            let literal_type = literal.discriminant();

            // Increment the token_idx by the tokens we have analyzed
            *token_idx += 1;

            // Check if there is an `As` keyword after the variable
            if let Some(Token::As) = tokens.get(*token_idx) {
                // If there isnt a TypeDefinition after the `As` keyword raise an error
                if let Some(Token::TypeDefinition(target_type)) = tokens.get(*token_idx + 1) {
                    // Increment the token index after checking target type
                    *token_idx += 2;

                    // Return the type casted literal
                    ParsedToken::TypeCast(
                        Box::new(ParsedToken::Literal(literal.clone())),
                        *target_type,
                    )
                } else {
                    // Throw an error
                    return Err(ParserError::SyntaxError(
                        super::error::SyntaxError::AsRequiresTypeDef,
                    )
                    .into());
                }
            } else {
                // If the literal's type doesn't match the variable's type return an error
                if literal_type != variable_type {
                    return Err(ParserError::TypeError(literal_type, variable_type).into());
                }

                // Push the ParsedToken to the list
                ParsedToken::Literal(literal.clone())
            }
        }
        Token::UnparsedLiteral(unparsed_literal) => {
            // Increment the token_idx by the tokens we have analyzed
            *token_idx += 1;

            // Push the ParsedToken to the list
            let parsed_token = ParsedToken::Literal(unparsed_const_to_typed_literal_unsafe(
                unparsed_literal.clone(),
                variable_type,
            )?);

            // Check if there is an `As` keyword after the variable
            if let Some(Token::As) = tokens.get(*token_idx) {
                // If there isnt a TypeDefinition after the `As` keyword raise an error
                if let Some(Token::TypeDefinition(target_type)) = tokens.get(*token_idx + 1) {
                    // Ezt lehet hogy késöbb ki kell majd venni
                    if *target_type != variable_type {
                        return Err(ParserError::TypeError(*target_type, variable_type).into());
                    }

                    // Increment the token index after checking target type
                    *token_idx += 2;

                    // Return the type casted literal
                    ParsedToken::TypeCast(Box::new(parsed_token), *target_type)
                } else {
                    // Throw an error
                    return Err(ParserError::SyntaxError(
                        super::error::SyntaxError::AsRequiresTypeDef,
                    )
                    .into());
                }
            } else {
                parsed_token
            }
        }
        Token::Identifier(identifier) => {
            // Try to find the identifier in the functions' list
            if let Some(function) = function_signatures.get(identifier) {
                // Parse the call arguments and tokens parsed.
                let (call_arguments, idx_jmp) = parse_functions::parse_function_call_args(
                    &tokens[*token_idx + 2..],
                    variable_scope,
                    function.function_sig.args.clone(),
                    function_signatures.clone(),
                )?;

                // Return the function call
                let parsed_token: ParsedToken = ParsedToken::FunctionCall(
                    (function.function_sig.clone(), identifier.clone()),
                    call_arguments,
                );

                // Increment the token index, and add the offset
                *token_idx += idx_jmp + 2 + 1;

                if let Some(Token::As) = tokens.get(*token_idx) {
                    if let Some(Token::TypeDefinition(target_type)) = tokens.get(*token_idx + 1) {
                        *token_idx += 2;

                        ParsedToken::TypeCast(Box::new(parsed_token), *target_type)
                    } else {
                        // Throw an error
                        return Err(ParserError::SyntaxError(
                            super::error::SyntaxError::AsRequiresTypeDef,
                        )
                        .into());
                    }
                } else {
                    // If the function's return type doesn't match the variable's return type return an error
                    if function.function_sig.return_type != variable_type {
                        return Err(ParserError::TypeError(
                            function.function_sig.return_type,
                            variable_type,
                        )
                        .into());
                    }

                    parsed_token
                }
            }
            // If the identifier could not be found in the function list search in the variable scope
            else if let Some(variable) = variable_scope.get(identifier) {
                let parsed_token = ParsedToken::VariableReference(identifier.clone());

                *token_idx += 1;

                if let Some(Token::As) = tokens.get(*token_idx) {
                    if let Some(Token::TypeDefinition(target_type)) = tokens.get(*token_idx + 1) {
                        // Ezt lehet hogy késöbb ki kell majd venni
                        if *target_type != variable_type {
                            return Err(ParserError::TypeError(*target_type, variable_type).into());
                        }

                        // Increment the token index after checking target type
                        *token_idx += 2;

                        // Return the type casted literal
                        return Ok(ParsedToken::TypeCast(Box::new(parsed_token), *target_type));
                    } else {
                        // Throw an error
                        return Err(ParserError::SyntaxError(
                            super::error::SyntaxError::AsRequiresTypeDef,
                        )
                        .into());
                    }
                }

                // If the variable's type doesnt match the one we want to modify throw an error.
                if variable_type != *variable {
                    return Err(ParserError::TypeError(*variable, variable_type).into());
                }

                // Return the VariableReference
                parsed_token
            } else {
                // If none of the above matches throw an error about the variable not being found
                return Err(ParserError::VariableNotFound(identifier.clone()).into());
            }
        }
        Token::OpenBracket => {
            *token_idx += 1;

            let closing_idx = find_closing_bracket(&tokens[*token_idx..])?;

            // Get the tokens inside the block aka the "()"
            let tokens_inside_block = &tokens[*token_idx..*token_idx + closing_idx];

            let (parsed_token, _jmp_idx) = parse_value(
                tokens_inside_block,
                function_signatures.clone(),
                variable_scope,
                variable_type,
            )?;

            *token_idx += closing_idx + 1;

            ParsedToken::MathematicalBlock(Box::new(parsed_token))
        }

        _ => {
            // If we are parsing something else than something that hold a value return an error.
            return Err(
                ParserError::SyntaxError(super::error::SyntaxError::InvalidValue(
                    eval_token.clone(),
                ))
                .into(),
            );
        }
    };
    Ok(inner_value)
}
