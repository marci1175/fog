use crate::app::type_system::type_system::{
    TypeDiscriminants, convert_as, unparsed_const_to_typed_literal,
    unparsed_const_to_typed_literal_unsafe,
};
use anyhow::Result;
use std::{
    collections::{HashMap, HashSet},
    sync::Arc,
};
use strum::IntoDiscriminant;

use super::{
    error::ParserError,
    parse_functions::{self, create_function_table, parse_functions},
    tokens::{FunctionDefinition, ParsedToken, Token, UnparsedFunctionDefinition},
};

#[derive(Debug, Clone)]
pub struct ParserState {
    tokens: Vec<Token>,

    function_table: HashMap<String, FunctionDefinition>,
}

impl ParserState {
    pub fn parse_tokens(&mut self) -> Result<()> {
        let unparsed_functions = create_function_table(self.tokens.clone())?;

        self.function_table = parse_functions(Arc::new(unparsed_functions))?;

        Ok(())
    }

    pub fn new(tokens: Vec<Token>) -> Self {
        Self {
            tokens,
            function_table: HashMap::new(),
        }
    }

    pub fn function_table(&self) -> &HashMap<String, FunctionDefinition> {
        &self.function_table
    }
}

pub fn find_closing_bracket(bracket_start_slice: &[Token]) -> Result<usize> {
    let mut bracket_layer_counter = 1;
    let iter = bracket_start_slice.iter().enumerate();

    for (idx, token) in iter {
        match token {
            Token::OpenBracket => bracket_layer_counter += 1,
            Token::CloseBracket => {
                bracket_layer_counter -= 1;
                if bracket_layer_counter == 0 {
                    return Ok(idx);
                }
            }
            _ => continue,
        }
    }

    Err(ParserError::SyntaxError(super::error::SyntaxError::OpenBraces).into())
}

pub fn parse_value(
    tokens: &[Token],
    function_signatures: Arc<HashMap<String, UnparsedFunctionDefinition>>,
    variable_scope: &HashMap<String, TypeDiscriminants>,
    variable_type: TypeDiscriminants,
) -> Result<(ParsedToken, usize)> {
    let mut token_idx = 0;

    let mut parsed_token: Option<ParsedToken> = None;

    while token_idx < tokens.len() {
        let current_token = &tokens.get(token_idx).ok_or({
            ParserError::SyntaxError(
                crate::app::parser::error::SyntaxError::InvalidMathematicalExpressionDefinition,
            )
        })?;

        // Please note that we are not looking at values by themselves, except in SetValue where we take the next token.
        match current_token {
            // If any mathematical expression is present in the tokens
            Token::Addition | Token::Subtraction | Token::Multiplication | Token::Division => {
                // Grab the next token after the mathematical expression
                let next_token = &tokens.get(token_idx + 1).ok_or(ParserError::SyntaxError(
                    crate::app::parser::error::SyntaxError::InvalidMathematicalExpressionDefinition,
                ))?;

                // If we have parsed something already move it to the left-hand side of the mathematical expression
                // Add the new parsed token to the right-hand side of the mathematical expression.
                if let Some(parsed_token) = &mut parsed_token {
                    // Modify the parsed token
                    *parsed_token = ParsedToken::MathematicalExpression(
                        // Move the token to the left side
                        Box::new(parsed_token.clone()),
                        // Add the Mathematical symbol to the enum variant
                        (*current_token).clone().try_into()?,
                        // Put the new item to the right side of the expr.
                        Box::new(parse_token_as_value(
                            tokens,
                            &function_signatures,
                            variable_scope,
                            variable_type,
                            &mut token_idx,
                            next_token,
                        )?),
                    );

                    token_idx += 1;
                } else {
                    return Err(ParserError::SyntaxError(
                        super::error::SyntaxError::InvalidMathematicalExpressionDefinition,
                    )
                    .into());
                }

                continue;
            }

            // This pattern match is purely for initializing the value of the variable.
            // The ParsedToken generated by the pattern match will not be evaluated in future iterations.
            Token::UnparsedLiteral(_raw_string) => {
                let parsed_value = parse_token_as_value(
                    tokens,
                    &function_signatures,
                    variable_scope,
                    variable_type,
                    &mut token_idx,
                    current_token,
                )?;

                // Initialize parsed token with a value.
                if parsed_token.is_none() {
                    parsed_token = Some(parsed_value.clone());
                }
            }

            // This pattern match is purely for initializing the value of the variable.
            // The ParsedToken generated by the pattern match will not be evaluated in future iterations.
            Token::Literal(_) => {
                let parsed_value = parse_token_as_value(
                    tokens,
                    &function_signatures,
                    variable_scope,
                    variable_type,
                    &mut token_idx,
                    current_token,
                )?;

                // Initialize parsed token with a value.
                if parsed_token.is_none() {
                    parsed_token = Some(parsed_value.clone());
                }
            }

            Token::Identifier(_) => {
                // Parse the next token (the identifier)
                let parsed_value = parse_token_as_value(
                    tokens,
                    &function_signatures,
                    variable_scope,
                    variable_type,
                    &mut token_idx,
                    current_token,
                )?;

                // Initialize parsed token with a value.
                if parsed_token.is_none() {
                    parsed_token = Some(parsed_value.clone());
                }
            }

            Token::Comma | Token::CloseBracket => break,

            _ => unimplemented!(),
        }

        // Increment token index
        token_idx += 1;
    }

    Ok((
        parsed_token.ok_or(ParserError::SyntaxError(
            super::error::SyntaxError::InvalidStatementDefinition,
        ))?,
        token_idx,
    ))
}

/// Parses the next token as something that holds a value:
/// Like: FunctionCall, Literal, UnparsedLiteral
pub fn parse_token_as_value(
    // This is used to parse the function call's arguments
    tokens: &[Token],
    // Functions available
    function_signatures: &Arc<HashMap<String, UnparsedFunctionDefinition>>,
    // Variables available
    variable_scope: &HashMap<String, TypeDiscriminants>,
    // The variable's type which we are parsing for
    variable_type: TypeDiscriminants,
    // Universal token_idx, this sets which token we are currently parsing
    token_idx: &mut usize,
    // The token we want to evaluate
    eval_token: &Token,
) -> Result<ParsedToken> {
    // Match the token
    let inner_value = match eval_token {
        Token::Literal(literal) => {
            let literal_type = literal.discriminant();

            // If the literal's type doesn't match the variable's type return an error
            if literal_type != variable_type {
                return Err(ParserError::TypeError(literal_type, variable_type).into());
            }

            // Increment the token_idx by the tokens we have analyzed
            *token_idx += 1;

            // Check if there is an `As` keyword after the variable
            if let Some(Token::As) = tokens.get(*token_idx) {
                // If there isnt a TypeDefinition after the `As` keyword raise an error
                if let Some(Token::TypeDefinition(target_type)) = tokens.get(*token_idx + 1) {
                    // Increment the token index after checking target type
                    *token_idx += 2;

                    // Return the type casted literal
                    ParsedToken::Literal(convert_as(literal.clone(), *target_type)?)
                } else {
                    // Throw an error
                    return Err(ParserError::SyntaxError(
                        super::error::SyntaxError::AsRequiresTypeDef,
                    )
                    .into());
                }
            } else {
                // Push the ParsedToken to the list
                ParsedToken::Literal(literal.clone())
            }
        }
        Token::UnparsedLiteral(unparsed_literal) => {
            // Increment the token_idx by the tokens we have analyzed
            *token_idx += 1;

            // Check if there is an `As` keyword after the variable
            if let Some(Token::As) = tokens.get(*token_idx) {
                // If there isnt a TypeDefinition after the `As` keyword raise an error
                if let Some(Token::TypeDefinition(target_type)) = tokens.get(*token_idx + 1) {
                    // Ezt lehet hogy késöbb ki kell majd venni
                    if *target_type != variable_type {
                        return Err(ParserError::TypeError(*target_type, variable_type).into());
                    }

                    // Increment the token index after checking target type
                    *token_idx += 2;

                    // Return the type casted literal
                    ParsedToken::Literal(unparsed_const_to_typed_literal_unsafe(
                        unparsed_literal.clone(),
                        *target_type,
                    )?)
                } else {
                    // Throw an error
                    return Err(ParserError::SyntaxError(
                        super::error::SyntaxError::AsRequiresTypeDef,
                    )
                    .into());
                }
            } else {
                // Push the ParsedToken to the list
                ParsedToken::Literal(unparsed_const_to_typed_literal_unsafe(
                    unparsed_literal.clone(),
                    variable_type,
                )?)
            }
        }
        Token::Identifier(identifier) => {
            // Try to find the identifier in the functions' list
            if let Some(function) = function_signatures.get(identifier) {
                // If the function's return type doesn't match the variable's return type return an error
                if function.function_sig.return_type != variable_type {
                    return Err(ParserError::TypeError(
                        function.function_sig.return_type,
                        variable_type,
                    )
                    .into());
                }

                // Parse the call arguments and tokens parsed.
                let (call_arguments, idx_jmp) = parse_functions::parse_function_call_args(
                    &tokens[*token_idx + 2..],
                    variable_scope,
                    function.function_sig.args.clone(),
                    function_signatures.clone(),
                )?;

                // Increment the token index, and add the offset
                *token_idx += idx_jmp + 2;

                // Return the function call
                ParsedToken::FunctionCall(
                    (function.function_sig.clone(), identifier.clone()),
                    call_arguments,
                )
            // If the identifier could not be found in the function list search in the variable scope
            } else if let Some(variable) = variable_scope.get(identifier) {
                // If the variable's type doesnt match the one we want to modify throw an error.
                if variable_type != *variable {
                    return Err(ParserError::TypeError(*variable, variable_type).into());
                }

                *token_idx += 1;

                // Return the VariableReference
                ParsedToken::VariableReference(identifier.clone())
            } else {
                // If none of the above matches throw an error about the variable not being found
                return Err(ParserError::VariableNotFound(identifier.clone()).into());
            }
        }

        _ => {
            // If we are parsing something else than something that hold a value return an error.
            return Err(
                ParserError::SyntaxError(super::error::SyntaxError::InvalidValue(
                    eval_token.clone(),
                ))
                .into(),
            );
        }
    };
    Ok(inner_value)
}
