use std::{collections::HashMap, sync::Arc};

use fog_common::{
    anyhow::Result,
    codegen::{CustomType, Order},
    error::{parser::ParserError, syntax::SyntaxError},
    indexmap::IndexMap,
    parser::{
        FunctionSignature, MathematicalSymbol, ParsedToken, StructFieldReference,
        UnparsedFunctionDefinition, VariableReference, find_closing_braces, find_closing_paren,
    },
    tokenizer::Token,
    ty::{OrdMap, TypeDiscriminant, token_to_ty, unparsed_const_to_typed_literal_unsafe},
};

use crate::parser::function::parse_function_call_args;

/// This is a top level implementation for `parse_token_as_value`
pub fn parse_value(
    tokens: &[Token],
    function_signatures: Arc<IndexMap<String, UnparsedFunctionDefinition>>,
    variable_scope: &mut IndexMap<String, TypeDiscriminant>,
    // Always pass in the desired variable type, you can only leave this `None` if you dont know the type by design
    mut desired_variable_type: Option<TypeDiscriminant>,
    function_imports: Arc<HashMap<String, FunctionSignature>>,
    custom_types: Arc<IndexMap<String, CustomType>>,
) -> Result<(ParsedToken, usize, TypeDiscriminant)>
{
    let mut token_idx = 0;

    // This is used for parsing mathematical expressions, comparisons
    let mut parsed_token: Option<ParsedToken> = None;
    let mut comparison_other_side_ty: Option<TypeDiscriminant> = None;

    while token_idx < tokens.len() {
        let current_token = &tokens.get(token_idx).ok_or({
            ParserError::SyntaxError(SyntaxError::InvalidMathematicalExpressionDefinition)
        })?;

        if let Some(next_token) = tokens.get(token_idx + 1)
            && (*next_token == Token::Equal
                || *next_token == Token::NotEqual
                || *next_token == Token::EqBigger
                || *next_token == Token::EqSmaller
                || *next_token == Token::Bigger
                || *next_token == Token::Smaller)
        {
            // TODO: Check why am I doing this.....
            desired_variable_type = None;
        }

        // Please note that we are not looking at values by themselves, except in SetValue where we take the next token.
        match current_token {
            // If any mathematical expression is present in the tokens
            Token::Addition | Token::Subtraction | Token::Multiplication | Token::Division => {
                // Grab the next token after the mathematical expression
                let next_token = &tokens.get(token_idx + 1).ok_or(ParserError::SyntaxError(
                    SyntaxError::InvalidMathematicalExpressionDefinition,
                ))?;

                // If we have parsed something already move it to the left-hand side of the mathematical expression
                // Add the new parsed token to the right-hand side of the mathematical expression.
                if let Some(parsed_token) = &mut parsed_token {
                    token_idx += 1;

                    // Modify the parsed token
                    *parsed_token = ParsedToken::MathematicalExpression(
                        // Move the token to the left side
                        Box::new(parsed_token.clone()),
                        // Add the Mathematical symbol to the enum variant
                        (*current_token).clone().try_into()?,
                        // Put the new item to the right side of the expr.
                        Box::new(
                            parse_token_as_value(
                                tokens,
                                function_signatures.clone(),
                                variable_scope,
                                desired_variable_type.clone(),
                                &mut token_idx,
                                next_token,
                                function_imports.clone(),
                                custom_types.clone(),
                            )?
                            .0,
                        ),
                    );
                }
                else {
                    return Err(ParserError::SyntaxError(
                        SyntaxError::InvalidMathematicalExpressionDefinition,
                    )
                    .into());
                }
            },

            // This pattern match is purely for initializing the value of the variable.
            // The ParsedToken generated by the pattern match will not be evaluated in future iterations.
            Token::UnparsedLiteral(_) => {
                let (parsed_value, ty) = parse_token_as_value(
                    tokens,
                    function_signatures.clone(),
                    variable_scope,
                    desired_variable_type.clone(),
                    &mut token_idx,
                    current_token,
                    function_imports.clone(),
                    custom_types.clone(),
                )?;

                // Initialize parsed token with a value.
                if parsed_token.is_none() {
                    parsed_token = Some(parsed_value);

                    comparison_other_side_ty = Some(ty);
                }
            },

            // This pattern match is purely for initializing the value of the variable.
            // The ParsedToken generated by the pattern match will not be evaluated in future iterations.
            Token::Identifier(_) | Token::OpenParentheses => {
                let (parsed_value, ty) = parse_token_as_value(
                    tokens,
                    function_signatures.clone(),
                    variable_scope,
                    desired_variable_type.clone(),
                    &mut token_idx,
                    current_token,
                    function_imports.clone(),
                    custom_types.clone(),
                )?;

                // Initialize parsed token with a value.
                if parsed_token.is_none() {
                    parsed_token = Some(parsed_value);
                    comparison_other_side_ty = Some(ty);
                }
            },

            Token::Literal(literal) => {
                let (parsed_value, ty) = parse_token_as_value(
                    tokens,
                    function_signatures.clone(),
                    variable_scope,
                    Some(literal.discriminant()),
                    &mut token_idx,
                    current_token,
                    function_imports.clone(),
                    custom_types.clone(),
                )?;

                // Initialize parsed token with a value.
                if parsed_token.is_none() {
                    parsed_token = Some(parsed_value);

                    comparison_other_side_ty = Some(ty);
                }
            },

            Token::Comma | Token::CloseParentheses | Token::SemiColon => {
                break;
            },

            Token::Equal
            | Token::NotEqual
            | Token::EqBigger
            | Token::EqSmaller
            | Token::Bigger
            | Token::Smaller => {
                if let Some(last_p_token) = &parsed_token {
                    token_idx += 1;

                    let next_token = &tokens[token_idx];

                    let (current_cmp_token, token_ty) = parse_token_as_value(
                        tokens,
                        function_signatures.clone(),
                        variable_scope,
                        comparison_other_side_ty.clone(),
                        &mut token_idx,
                        next_token,
                        function_imports.clone(),
                        custom_types.clone(),
                    )?;

                    parsed_token = Some(ParsedToken::Comparison(
                        Box::new(last_p_token.clone()),
                        Order::from_token(current_token)?,
                        Box::new(current_cmp_token),
                        token_ty,
                    ));
                }
            },

            Token::OpenBraces => {
                let (parsed_value, ty) = parse_token_as_value(
                    tokens,
                    function_signatures.clone(),
                    variable_scope,
                    desired_variable_type.clone(),
                    &mut token_idx,
                    current_token,
                    function_imports.clone(),
                    custom_types.clone(),
                )?;

                // Initialize parsed token with a value.
                if parsed_token.is_none() {
                    parsed_token = Some(parsed_value);
                    comparison_other_side_ty = Some(ty);
                }
            },

            Token::As => {
                if let Some(last_token) = &parsed_token {
                    if let Some(Token::TypeDefinition(target_type)) = tokens.get(token_idx + 1) {
                        token_idx += 2;

                        parsed_token = Some(ParsedToken::TypeCast(
                            Box::new(last_token.clone()),
                            target_type.clone(),
                        ));
                        comparison_other_side_ty = Some(target_type.clone());
                    }
                    else {
                        // Throw an error
                        return Err(ParserError::SyntaxError(SyntaxError::AsRequiresTypeDef).into());
                    }
                }
            },

            _ => {
                dbg!(parsed_token);
                dbg!(current_token);

                unimplemented!()
            },
        }
    }

    Ok((
        parsed_token.ok_or(ParserError::SyntaxError(
            SyntaxError::InvalidStatementDefinition,
        ))?,
        token_idx,
        comparison_other_side_ty.ok_or(ParserError::SyntaxError(
            SyntaxError::InvalidStatementDefinition,
        ))?,
    ))
}

/// Parses the next token as something that holds a value:
/// Like: FunctionCall, Literal, UnparsedLiteral
pub fn parse_token_as_value(
    // This is used to parse the function call's arguments
    tokens: &[Token],
    // Functions available
    function_signatures: Arc<IndexMap<String, UnparsedFunctionDefinition>>,
    // Variables available
    variable_scope: &mut IndexMap<String, TypeDiscriminant>,
    // The variable's type which we are parsing for
    desired_variable_type: Option<TypeDiscriminant>,
    // Universal token_idx, this sets which token we are currently parsing
    token_idx: &mut usize,
    // The token we want to evaluate, this is the first token of the slice most of the time
    eval_token: &Token,
    function_imports: Arc<HashMap<String, FunctionSignature>>,
    custom_types: Arc<IndexMap<String, CustomType>>,
) -> Result<(ParsedToken, TypeDiscriminant)>
{
    // Match the token
    let inner_value = match eval_token {
        Token::Literal(literal) => {
            // Increment the token_idx by the tokens we have analyzed
            *token_idx += 1;

            // Check if there is an `As` keyword after the variable
            if let Some(Token::As) = tokens.get(*token_idx) {
                // If there isnt a TypeDefinition after the `As` keyword raise an error
                if let Some(Token::TypeDefinition(target_type)) = tokens.get(*token_idx + 1) {
                    // Increment the token index after checking target type
                    *token_idx += 2;

                    // Return the type casted literal
                    (
                        ParsedToken::TypeCast(
                            Box::new(ParsedToken::Literal(literal.clone())),
                            target_type.clone(),
                        ),
                        target_type.clone(),
                    )
                }
                else {
                    // Throw an error
                    return Err(ParserError::SyntaxError(SyntaxError::AsRequiresTypeDef).into());
                }
            }
            else {
                // Push the ParsedToken to the list
                (
                    ParsedToken::Literal(literal.clone()),
                    literal.discriminant(),
                )
            }
        },
        Token::UnparsedLiteral(unparsed_literal) => {
            // Increment the token_idx by the tokens we have analyzed
            *token_idx += 1;

            // Push the ParsedToken to the list
            let parsed_value = unparsed_const_to_typed_literal_unsafe(
                unparsed_literal.clone(),
                desired_variable_type.clone(),
            )?;

            let parsed_token = ParsedToken::Literal(parsed_value.clone());

            // Check if there is an `As` keyword after the variable
            if let Some(Token::As) = tokens.get(*token_idx) {
                // If there isnt a TypeDefinition after the `As` keyword raise an error
                if let Some(Token::TypeDefinition(target_type)) = tokens.get(*token_idx + 1) {
                    // Increment the token index after checking target type
                    *token_idx += 2;

                    // Return the type casted literal
                    (
                        ParsedToken::TypeCast(Box::new(parsed_token), target_type.clone()),
                        target_type.clone(),
                    )
                }
                else {
                    // Throw an error
                    return Err(ParserError::SyntaxError(SyntaxError::AsRequiresTypeDef).into());
                }
            }
            else {
                (parsed_token, parsed_value.discriminant())
            }
        },
        Token::Identifier(identifier) => {
            // Try to find the identifier in the functions' list
            if let Some(function) = function_signatures.get(identifier) {
                // Parse the call arguments and tokens parsed.
                let (call_arguments, idx_jmp) = parse_function_call_args(
                    &tokens[*token_idx + 2..],
                    variable_scope,
                    function.function_sig.args.clone(),
                    function_signatures.clone(),
                    function_imports.clone(),
                    custom_types.clone(),
                )?;

                // Return the function call
                let parsed_token: ParsedToken = ParsedToken::FunctionCall(
                    (function.function_sig.clone(), identifier.clone()),
                    call_arguments,
                );

                // Increment the token index, and add the offset
                *token_idx += idx_jmp + 2 + 1;

                if let Some(Token::As) = tokens.get(*token_idx) {
                    if let Some(Token::TypeDefinition(target_type)) = tokens.get(*token_idx + 1) {
                        *token_idx += 2;

                        (
                            ParsedToken::TypeCast(Box::new(parsed_token), target_type.clone()),
                            target_type.clone(),
                        )
                    }
                    else {
                        // Throw an error
                        return Err(ParserError::SyntaxError(SyntaxError::AsRequiresTypeDef).into());
                    }
                }
                else {
                    // If there is a desired variable type then check if the two types match
                    if let Some(desired_variable_type) = desired_variable_type {
                        // If the function's return type doesn't match the variable's return type return an error
                        if function.function_sig.return_type != desired_variable_type {
                            return Err(ParserError::TypeError(
                                function.function_sig.return_type.clone(),
                                desired_variable_type,
                            )
                            .into());
                        }

                        (parsed_token, desired_variable_type)
                    }
                    // If there were no explicit type definitions, return the type which is produced by the function
                    else {
                        (parsed_token, function.function_sig.return_type.clone())
                    }
                }
            }
            // If the identifier could not be found in the function list search in the variable scope
            else if let Some(variable_type) = variable_scope.get(identifier).cloned() {
                let basic_reference = VariableReference::BasicReference(identifier.clone());

                let parsed_token = ParsedToken::VariableReference(basic_reference.clone());

                *token_idx += 1;

                let (parsed_token, variable_type) = handle_variable(
                    tokens,
                    &function_signatures,
                    variable_scope,
                    desired_variable_type,
                    token_idx,
                    &function_imports,
                    &custom_types,
                    identifier,
                    basic_reference,
                    parsed_token,
                    variable_type.clone(),
                )?;

                // Return the VariableReference
                (parsed_token, variable_type.clone())
            }
            else if let Some(function_sig) = function_imports.get(identifier) {
                // Parse the call arguments and tokens parsed.
                let (call_arguments, idx_jmp) = parse_function_call_args(
                    &tokens[*token_idx + 2..],
                    variable_scope,
                    function_sig.args.clone(),
                    function_signatures.clone(),
                    function_imports.clone(),
                    custom_types.clone(),
                )?;

                // Return the function call
                let parsed_token: ParsedToken = ParsedToken::FunctionCall(
                    (function_sig.clone(), identifier.clone()),
                    call_arguments,
                );

                // Increment the token index, and add the offset
                *token_idx += idx_jmp + 2 + 1;

                if let Some(Token::As) = tokens.get(*token_idx) {
                    if let Some(Token::TypeDefinition(target_type)) = tokens.get(*token_idx + 1) {
                        *token_idx += 2;

                        (
                            ParsedToken::TypeCast(Box::new(parsed_token), target_type.clone()),
                            target_type.clone(),
                        )
                    }
                    else {
                        // Throw an error
                        return Err(ParserError::SyntaxError(SyntaxError::AsRequiresTypeDef).into());
                    }
                }
                else {
                    let desired_variable_type =
                        desired_variable_type.ok_or(ParserError::InternalDesiredTypeMissing)?;

                    // If the function's return type doesn't match the variable's return type return an error
                    if function_sig.return_type != desired_variable_type {
                        return Err(ParserError::TypeError(
                            function_sig.return_type.clone(),
                            desired_variable_type,
                        )
                        .into());
                    }

                    (parsed_token, desired_variable_type)
                }
            }
            else if let Some(custom_type) = custom_types.get(identifier) {
                match custom_type {
                    CustomType::Struct((_struct_name, struct_inner)) => {
                        if let Some(Token::OpenBraces) = tokens.get(*token_idx + 1) {
                            let closing_idx = find_closing_braces(&tokens[*token_idx + 2..], 0)?;

                            let struct_init_slice =
                                &tokens[*token_idx + 2..*token_idx + 2 + closing_idx];

                            let (_jump_idx, init_struct_token) = init_struct(
                                struct_init_slice,
                                struct_inner,
                                function_signatures.clone(),
                                function_imports,
                                custom_types.clone(),
                                variable_scope,
                            )?;

                            *token_idx = *token_idx + 2 + closing_idx + 1;

                            return Ok((
                                init_struct_token,
                                TypeDiscriminant::Struct((
                                    _struct_name.clone(),
                                    struct_inner.clone(),
                                )),
                            ));
                        }

                        return Err(ParserError::SyntaxError(
                            SyntaxError::InvalidStructFieldDefinition,
                        )
                        .into());
                    },
                    CustomType::Enum(index_map) => {
                        todo!()
                    },
                }
            }
            else {
                // If none of the above matches throw an error about the variable not being found
                return Err(ParserError::VariableNotFound(identifier.clone()).into());
            }
        },
        Token::OpenParentheses => {
            *token_idx += 1;

            let closing_idx = find_closing_paren(&tokens[*token_idx..], 0)?;

            // Get the tokens inside the block aka the "()"
            let tokens_inside_block = &tokens[*token_idx..*token_idx + closing_idx];

            let desired_variable_type =
                desired_variable_type.ok_or(ParserError::InternalDesiredTypeMissing)?;

            let (parsed_token, _jmp_idx, _) = parse_value(
                tokens_inside_block,
                function_signatures.clone(),
                variable_scope,
                Some(desired_variable_type.clone()),
                function_imports,
                custom_types.clone(),
            )?;

            *token_idx += closing_idx + 1;

            (
                ParsedToken::MathematicalBlock(Box::new(parsed_token)),
                desired_variable_type.clone(),
            )
        },
        Token::OpenBraces => {
            *token_idx += 1;

            let closing_idx = find_closing_braces(&tokens[*token_idx..], 0)?;

            let tokens_inside_block = &tokens[*token_idx..*token_idx + closing_idx];

            let desired_variable_type =
                desired_variable_type.ok_or(ParserError::InternalDesiredTypeMissing)?;

            let mut array_item_idx = 0;

            let mut vec_values = Vec::new();

            // We will check for the valid length of the init value later, at codegen.
            if let TypeDiscriminant::Array((inner_token, _len)) = &desired_variable_type {
                let inner_ty = token_to_ty((**inner_token).clone(), custom_types.clone())?;

                while array_item_idx < tokens_inside_block.len() {
                    // Parse the value of the array
                    let (parsed_token, jump_index, _) = parse_value(
                        &tokens_inside_block[array_item_idx..],
                        function_signatures.clone(),
                        variable_scope,
                        Some(inner_ty.clone()),
                        function_imports.clone(),
                        custom_types.clone(),
                    )?;

                    // Store the parsed token
                    vec_values.push(parsed_token);

                    // Increment the idx counter
                    array_item_idx += jump_index + 1;
                }

                // Increment the token index to the end of the array's tokens.
                *token_idx += array_item_idx;

                // Return the final parsed token.
                return Ok((
                    ParsedToken::ArrayInitialization(vec_values, inner_ty.clone()),
                    desired_variable_type.clone(),
                ));
            }
            else {
                return Err(ParserError::TypeMismatchNonIndexable(desired_variable_type).into());
            }
        },
        _ => {
            // If we are parsing something else than something that hold a value return an error.
            return Err(
                ParserError::SyntaxError(SyntaxError::InvalidValue(eval_token.clone())).into(),
            );
        },
    };

    Ok(inner_value)
}

pub fn parse_variable_expression(
    tokens: &[Token],
    current_token: &Token,
    token_idx: &mut usize,
    function_signatures: Arc<IndexMap<String, UnparsedFunctionDefinition>>,
    function_imports: Arc<HashMap<String, FunctionSignature>>,
    variable_scope: &mut IndexMap<String, TypeDiscriminant>,
    variable_type: TypeDiscriminant,
    custom_types: Arc<IndexMap<String, CustomType>>,
    variable_ref: ParsedToken,
    parsed_tokens: &mut Vec<ParsedToken>,
) -> Result<()>
{
    match &current_token {
        Token::SetValue => {
            let line_break_idx = tokens
                .iter()
                .skip(*token_idx)
                .position(|token| *token == Token::SemiColon)
                .ok_or(ParserError::SyntaxError(SyntaxError::MissingLineBreak))?
                + *token_idx;

            let selected_tokens = &tokens[*token_idx + 1..line_break_idx];

            *token_idx += selected_tokens.len() + 1;

            let (parsed_token, _, _) = parse_value(
                selected_tokens,
                function_signatures.clone(),
                variable_scope,
                Some(variable_type.clone()),
                function_imports.clone(),
                custom_types.clone(),
            )?;

            parsed_tokens.push(ParsedToken::SetValue(
                Box::new(variable_ref.clone()),
                Box::new(parsed_token),
            ));
        },
        Token::SetValueAddition => {
            set_value_math_expr(
                tokens,
                function_signatures,
                token_idx,
                parsed_tokens,
                variable_scope,
                variable_type,
                variable_ref.clone(),
                MathematicalSymbol::Addition,
                function_imports.clone(),
                custom_types.clone(),
            )?;
        },
        Token::SetValueSubtraction => {
            set_value_math_expr(
                tokens,
                function_signatures,
                token_idx,
                parsed_tokens,
                variable_scope,
                variable_type,
                variable_ref.clone(),
                MathematicalSymbol::Subtraction,
                function_imports.clone(),
                custom_types.clone(),
            )?;
        },
        Token::SetValueDivision => {
            set_value_math_expr(
                tokens,
                function_signatures,
                token_idx,
                parsed_tokens,
                variable_scope,
                variable_type,
                variable_ref.clone(),
                MathematicalSymbol::Division,
                function_imports.clone(),
                custom_types.clone(),
            )?;
        },
        Token::SetValueMultiplication => {
            set_value_math_expr(
                tokens,
                function_signatures,
                token_idx,
                parsed_tokens,
                variable_scope,
                variable_type,
                variable_ref.clone(),
                MathematicalSymbol::Multiplication,
                function_imports.clone(),
                custom_types.clone(),
            )?;
        },
        Token::SetValueModulo => {
            set_value_math_expr(
                tokens,
                function_signatures,
                token_idx,
                parsed_tokens,
                variable_scope,
                variable_type,
                variable_ref.clone(),
                MathematicalSymbol::Modulo,
                function_imports.clone(),
                custom_types.clone(),
            )?;
        },
        Token::Dot => {
            let field_name = &tokens.get(*token_idx + 1);

            if let TypeDiscriminant::Struct((struct_name, struct_def)) = variable_type {
                if let Some(Token::Identifier(field_name)) = field_name {
                    if let Some(struct_field_ty) = struct_def.get(field_name) {
                        // match &mut variable_ref {
                        //     VariableReference::StructFieldReference(
                        //         struct_field_reference,
                        //         struct_ty,
                        //     ) => {
                        //         struct_field_reference
                        //             .field_stack
                        //             .push(field_name.to_string());
                        //     }
                        //     VariableReference::BasicReference(basic_ref) => {
                        //         variable_ref = VariableReference::StructFieldReference(
                        //             StructFieldReference::from_stack(vec![
                        //                 basic_ref.to_string(),
                        //                 field_name.to_string(),
                        //             ]),
                        //             (struct_name, struct_def.clone()),
                        //         );
                        //     }
                        //     VariableReference::ArrayReference(_, parsed_tokens) => todo!(),
                        // }

                        *token_idx += 2;

                        parse_variable_expression(
                            tokens,
                            &tokens[*token_idx],
                            token_idx,
                            function_signatures,
                            function_imports,
                            variable_scope,
                            struct_field_ty.clone(),
                            custom_types,
                            // This is not going to work we may need to rework struct references.
                            variable_ref,
                            parsed_tokens,
                        )?;
                    }
                    else {
                        return Err(ParserError::SyntaxError(SyntaxError::StructFieldNotFound(
                            field_name.to_string(),
                            (struct_name, struct_def),
                        ))
                        .into());
                    }
                }
                else {
                    return Err(ParserError::SyntaxError(SyntaxError::StructFieldNotFound(
                        format!("{field_name:?}"),
                        (struct_name, struct_def),
                    ))
                    .into());
                }
            }
            else {
                return Err(ParserError::SyntaxError(SyntaxError::InvalidDotPlacement).into());
            }

            if let Some(idx) = tokens
                .iter()
                .skip(*token_idx)
                .position(|token| *token == Token::SemiColon)
            {
                *token_idx += idx;
            }
            else {
                return Err(ParserError::SyntaxError(SyntaxError::MissingLineBreak).into());
            }
        },
        Token::OpenSquareBrackets => {
            if let TypeDiscriminant::Array((inner_token, len)) = variable_type {
                let inner_type = token_to_ty(*inner_token, custom_types.clone())?;

                *token_idx += 1;

                let square_brackets_break_idx = tokens
                    .iter()
                    .skip(*token_idx)
                    .position(|token| *token == Token::CloseSquareBrackets)
                    .ok_or(ParserError::SyntaxError(
                        SyntaxError::LeftOpenSquareBrackets,
                    ))?
                    + *token_idx;

                let selected_tokens = &tokens[*token_idx..square_brackets_break_idx];

                let (value, idx_jmp, _) = parse_value(
                    selected_tokens,
                    function_signatures.clone(),
                    variable_scope,
                    Some(TypeDiscriminant::U32),
                    function_imports.clone(),
                    custom_types.clone(),
                )?;

                *token_idx += idx_jmp;

                if let Some(Token::CloseSquareBrackets) = tokens.get(*token_idx) {
                    *token_idx += 1;

                    if tokens.get(*token_idx) != Some(&Token::SemiColon) {
                        let next_token = tokens.get(*token_idx).ok_or(ParserError::SyntaxError(
                            SyntaxError::InvalidStatementDefinition,
                        ))?;

                        parse_variable_expression(
                            tokens,
                            next_token,
                            token_idx,
                            function_signatures.clone(),
                            function_imports,
                            variable_scope,
                            inner_type,
                            custom_types,
                            ParsedToken::ArrayIndexing(
                                Box::new(variable_ref.clone()),
                                Box::new(value.clone()),
                            ),
                            parsed_tokens,
                        )?;
                    }
                    else {
                        // parsed_tokens.push(ParsedToken::ArrayIndexing(
                        //     Box::new(ParsedToken::VariableReference(variable_ref.clone())),
                        //     Box::new(value),
                        // ));

                        panic!("Check later if this is a syntax check.")
                    }
                }
                else {
                    return Err(
                        ParserError::SyntaxError(SyntaxError::LeftOpenSquareBrackets).into(),
                    );
                }
            }
            else {
                return Err(ParserError::TypeMismatchNonIndexable(variable_type).into());
            }
        },
        _ => {
            println!("[ERROR] Unimplemented token: {}", tokens[*token_idx]);
        },
    }

    Ok(())
}

fn handle_variable(
    tokens: &[Token],
    function_signatures: &Arc<IndexMap<String, UnparsedFunctionDefinition>>,
    variable_scope: &mut IndexMap<String, TypeDiscriminant>,
    desired_variable_type: Option<TypeDiscriminant>,
    token_idx: &mut usize,
    function_imports: &Arc<HashMap<String, FunctionSignature>>,
    custom_types: &Arc<IndexMap<String, CustomType>>,
    identifier: &String,
    variable_reference: VariableReference,
    // Last parsed token parsed
    parsed_token: ParsedToken,
    // Last parsed token's type
    variable_type: TypeDiscriminant,
) -> Result<(ParsedToken, TypeDiscriminant)>
{
    if let Some(Token::As) = tokens.get(*token_idx) {
        if let Some(Token::TypeDefinition(target_type)) = tokens.get(*token_idx + 1) {
            let desired_variable_type =
                desired_variable_type.ok_or(ParserError::InternalDesiredTypeMissing)?;

            if *target_type != desired_variable_type {
                return Err(
                    ParserError::TypeError(target_type.clone(), desired_variable_type).into(),
                );
            }

            // Increment the token index after checking target type
            *token_idx += 2;

            let handling_continuation = handle_variable(
                tokens,
                function_signatures,
                variable_scope,
                Some(desired_variable_type),
                token_idx,
                function_imports,
                custom_types,
                identifier,
                variable_reference,
                ParsedToken::TypeCast(Box::new(parsed_token), target_type.clone()),
                target_type.clone(),
            )?;

            // Return the type casted literal
            Ok(handling_continuation)
        }
        else {
            // Throw an error
            Err(ParserError::SyntaxError(SyntaxError::AsRequiresTypeDef).into())
        }
    }
    else if let Some(Token::Dot) = tokens.get(*token_idx) {
        if let TypeDiscriminant::Struct(struct_def) = variable_type {
            *token_idx += 1;

            let mut struct_field_reference =
                StructFieldReference::from_single_entry(identifier.clone());

            let field_type = get_struct_field_stack(
                tokens,
                token_idx,
                identifier,
                &struct_def,
                &mut struct_field_reference,
            )?;

            let handling_continuation = handle_variable(
                tokens,
                function_signatures,
                variable_scope,
                desired_variable_type,
                token_idx,
                function_imports,
                custom_types,
                identifier,
                VariableReference::StructFieldReference(
                    struct_field_reference.clone(),
                    struct_def.clone(),
                ),
                ParsedToken::VariableReference(VariableReference::StructFieldReference(
                    struct_field_reference,
                    struct_def.clone(),
                )),
                field_type,
            )?;

            Ok(handling_continuation)
        }
        else {
            Err(ParserError::SyntaxError(SyntaxError::InvalidStructName(identifier.clone())).into())
        }
    }
    else if let Some(Token::OpenSquareBrackets) = tokens.get(*token_idx) {
        if !matches!(variable_type, TypeDiscriminant::Array(_)) {
            return Err(ParserError::TypeMismatchNonIndexable(variable_type.clone()).into());
        }

        *token_idx += 1;

        let square_brackets_break_idx = tokens
            .iter()
            .skip(*token_idx)
            .position(|token| *token == Token::CloseSquareBrackets)
            .ok_or(ParserError::SyntaxError(
                SyntaxError::LeftOpenSquareBrackets,
            ))?
            + *token_idx;

        let selected_tokens = &tokens[*token_idx..square_brackets_break_idx];

        let (value, idx_jmp, _) = parse_value(
            selected_tokens,
            function_signatures.clone(),
            variable_scope,
            Some(TypeDiscriminant::U32),
            function_imports.clone(),
            custom_types.clone(),
        )?;

        *token_idx += idx_jmp;

        if let Some(Token::CloseSquareBrackets) = tokens.get(*token_idx) {
            *token_idx += 1;

            if let TypeDiscriminant::Array((inner_ty, _len)) = variable_type.clone() {
                let handling_continuation = handle_variable(
                    tokens,
                    function_signatures,
                    variable_scope,
                    desired_variable_type,
                    token_idx,
                    function_imports,
                    custom_types,
                    identifier,
                    VariableReference::ArrayReference(identifier.clone(), Box::new(value.clone())),
                    ParsedToken::ArrayIndexing(
                        Box::new(ParsedToken::VariableReference(variable_reference.clone())),
                        Box::new(value),
                    ),
                    token_to_ty(*inner_ty.clone(), custom_types.clone())?,
                )?;

                Ok(handling_continuation)
            }
            else {
                unreachable!(
                    "This is unreachable as there is a type check at the beginning of this code."
                );
            }
        }
        else {
            Err(ParserError::SyntaxError(SyntaxError::LeftOpenSquareBrackets).into())
        }
    }
    else {
        Ok((parsed_token.clone(), variable_type.clone()))
    }
}

fn set_value_math_expr(
    tokens: &[Token],
    function_signatures: Arc<IndexMap<String, UnparsedFunctionDefinition>>,
    token_idx: &mut usize,
    parsed_tokens: &mut Vec<ParsedToken>,
    variable_scope: &mut IndexMap<String, TypeDiscriminant>,
    variable_type: TypeDiscriminant,
    variable_reference: ParsedToken,
    math_symbol: MathematicalSymbol,
    standard_function_table: Arc<HashMap<String, FunctionSignature>>,
    custom_items: Arc<IndexMap<String, CustomType>>,
) -> Result<()>
{
    *token_idx += 1;

    let eval_token = tokens.get(*token_idx).ok_or(ParserError::SyntaxError(
        SyntaxError::InvalidStatementDefinition,
    ))?;

    let (next_token, ty) = parse_token_as_value(
        tokens,
        function_signatures,
        variable_scope,
        Some(variable_type.clone()),
        token_idx,
        eval_token,
        standard_function_table,
        custom_items.clone(),
    )?;

    parsed_tokens.push(ParsedToken::SetValue(
        Box::new(variable_reference.clone()),
        Box::new(ParsedToken::MathematicalExpression(
            Box::new(variable_reference),
            math_symbol,
            Box::new(next_token),
        )),
    ));

    Ok(())
}

fn get_struct_field_stack(
    tokens: &[Token],
    token_idx: &mut usize,
    identifier: &String,
    (struct_name, struct_fields): &(String, OrdMap<String, TypeDiscriminant>),
    struct_field_stack: &mut StructFieldReference,
) -> Result<TypeDiscriminant>
{
    if let Some(Token::Identifier(field_name)) = tokens.get(*token_idx) {
        let struct_field_query = struct_fields.get(field_name);
        if let Some(TypeDiscriminant::Struct(struct_def)) = struct_field_query {
            *token_idx += 1;

            struct_field_stack.field_stack.push(field_name.clone());

            if let Some(Token::Dot) = tokens.get(*token_idx) {
                *token_idx += 1;

                get_struct_field_stack(
                    tokens,
                    token_idx,
                    identifier,
                    struct_def,
                    struct_field_stack,
                )
            }
            else {
                Err(ParserError::SyntaxError(SyntaxError::InvalidStructDefinition).into())
            }
        }
        else if let Some(field_type) = struct_field_query {
            *token_idx += 1;

            struct_field_stack.field_stack.push(field_name.clone());

            Ok(field_type.clone())
        }
        else {
            Err(ParserError::SyntaxError(SyntaxError::StructFieldNotFound(
                field_name.clone(),
                (struct_name.clone(), struct_fields.clone()),
            ))
            .into())
        }
    }
    else {
        Err(ParserError::SyntaxError(SyntaxError::InvalidStructFieldReference).into())
    }
}

pub fn init_struct(
    struct_slice: &[Token],
    this_struct_field: &IndexMap<String, TypeDiscriminant>,
    function_signatures: Arc<IndexMap<String, UnparsedFunctionDefinition>>,
    function_imports: Arc<HashMap<String, FunctionSignature>>,
    custom_types: Arc<IndexMap<String, CustomType>>,
    variable_scope: &mut IndexMap<String, TypeDiscriminant>,
) -> Result<(usize, ParsedToken)>
{
    let mut struct_field_init_map: IndexMap<String, Box<ParsedToken>> = IndexMap::new();

    let mut idx: usize = 0;

    let mut nth_field: usize = 0;

    while idx < struct_slice.len() {
        if let Some(Token::Identifier(field_name)) = struct_slice.get(idx)
            && let Some(Token::Colon) = struct_slice.get(idx + 1)
        {
            let selected_tokens = &struct_slice[idx + 2..];

            let (parsed_value, jump_idx, _) = parse_value(
                selected_tokens,
                function_signatures.clone(),
                variable_scope,
                Some(
                    this_struct_field
                        .get(field_name)
                        .ok_or(ParserError::SyntaxError(
                            SyntaxError::InvalidStructFieldDefinition,
                        ))?
                        .clone(),
                ),
                function_imports.clone(),
                custom_types.clone(),
            )?;

            idx += jump_idx + 2;

            struct_field_init_map.insert(field_name.to_string(), Box::new(parsed_value));

            if let Some(Token::Comma) = struct_slice.get(idx) {
                nth_field += 1;
                idx += 1;
                continue;
            }
            else if nth_field + 1 == this_struct_field.len() {
                nth_field += 1;
                idx += 1;
                continue;
            }
        }

        return Err(ParserError::SyntaxError(SyntaxError::InvalidStructFieldDefinition).into());
    }

    Ok((
        idx,
        ParsedToken::InitializeStruct(
            this_struct_field.clone().into(),
            struct_field_init_map.into(),
        ),
    ))
}
